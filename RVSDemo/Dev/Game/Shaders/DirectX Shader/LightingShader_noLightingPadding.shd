/////////////////////////////////////////////////////////////////////////////////
//																			   //
//		SIMPLE LIGHTINGSHADER	(NO LIGHTING, ONLY COLOR TEXTURE)			   //
//																			   //
/////////////////////////////////////////////////////////////////////////////////

// Input data
struct VsIn 
{
	float3 vertexPosition_modelspace : Position;
};

// Output data
struct PsIn 
{
	float4 vertexPosition_worldspace : SV_Position;
	float2 vertexUV					 : TexCoord0;
	float3 ViewRay				 	 : TexCoord1;
};

[Vertex shader]

//Uniform Matrix
float4x4 InverseView;
float4x4 InverseProjection;

float4 cameraPos;

PsIn main(VsIn In)
{
	PsIn output;
	
	output.vertexPosition_worldspace = float4(In.vertexPosition_modelspace, 1.0f);
	output.vertexUV = (In.vertexPosition_modelspace.xy+float2(1,1))*0.5f;
	output.vertexUV.y = 1.0f - output.vertexUV.y;
	
	float4 positionWS = mul(float4(In.vertexPosition_modelspace, 1.0f), mul(InverseProjection, InverseView));
	positionWS /= positionWS.w;
	
	output.ViewRay = positionWS - cameraPos;
	
	return output;
 }

[Fragment shader]

//Frustum Partition Struct and Buffer///////////
/*struct FrustumPartition
{
	float fBeginPartiton;
	float fEndPartition;
	float2 unused;
	float4 scale;
	float4 bias;
};

layout(std430, binding = 9) buffer blockBuffer
{
	FrustumPartition frustumPartitionBuffer[];
};*/
////////////////////////////////////////////////

//Target Textures
Texture2D depthTarget;
Texture2D normalTarget;
Texture2D baseTarget;
Texture2D indirectDiffuseTarget;
Texture2D indirectSpecularTarget;

//Sampler
SamplerState TargetSample;

//General Light constants
float lightIntensitive[10];
float4 lightColor[10];
int lightType[10];

//Directional Light constants
float4 lightDirection[10];
float4x4 lightViewMat[10];

//Point Light constants
float4 positionLight[10];
float lightRange[10];
float3 attenuationCoeficient[10];

//Spot Light constant
float thetaAngle[10];
float phiAngle[10];

//Num Lights in Packet
int numLights;

//Camera constant
float4 cameraPosition;

//Shadow constant
Texture2D atlasShadowSampler;

float2 uvCordShadow[60];
float shadowMapTam[60];
float4x4 projLightMat[10];

float inverseAtlasSize;

//Emissive constant
int bOneTimeEmissive;

//Matrix
float4x4 View;
float4x4 Projection;

 // Returns a random number based on a float3 and an int.
float fract(float x)
{
	return x - floor(x);
}
 
float random(float3 seed, int i)
{
	float4 seed4 = float4(seed,i);
	float dot_product = dot(seed4, float4(12.9898,78.233,45.164,94.673));
	return fract(sin(dot_product) * 43758.5453);
}

float4x4 cubeMapping(float3 dir, int index, out int cubeFace)
{
	//dir must be normalized
	float3 normalizedDir = normalize(dir);
	
	float maxCoord = max(abs(normalizedDir.x), max(abs(normalizedDir.y), abs(normalizedDir.z)));
	
	if(maxCoord == abs(normalizedDir.x))
	{
		if(normalizedDir.x > 0)
		{
			cubeFace = 0;
			
			float posX = -dot(positionLight[index].xyz, float3(0.0f, 0.0f, -1.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, -1.0f, 0.0f));
			float posZ = -dot(positionLight[index].xyz, float3(-1.0f, 0.0f, 0.0f));
			
			return float4x4(0.0f, 0.0f, 1.0f, 0.0f,
							0.0f,-1.0f, 0.0f, 0.0f,
						   -1.0f, 0.0f, 0.0f, 0.0f,
							posX, posY, posZ, 1.0f);
		}				
		else
		{
			cubeFace = 1;
			
			float posX = -dot(positionLight[index].xyz, float3(0.0f, 0.0f, 1.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, -1.0f, 0.0f));
			float posZ = -dot(positionLight[index].xyz, float3(1.0f, 0.0f, 0.0f));
			
			return float4x4(0.0f, 0.0f,-1.0f, 0.0f,
							0.0f,-1.0f, 0.0f, 0.0f,
							1.0f, 0.0f, 0.0f, 0.0f,
							posX, posY, posZ, 1.0f);
		}
	}
	else if(maxCoord == abs(normalizedDir.y))
	{
		if(normalizedDir.y > 0)
		{
			cubeFace = 3;
			
			float posX = -dot(positionLight[index].xyz, float3(1.0f, 0.0f, 0.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, 0.0f, 1.0f));
			float posZ = -dot(positionLight[index].xyz, float3(0.0f, -1.0f, 0.0f));
			
			return float4x4(1.0f, 0.0f, 0.0f, 0.0f,
							0.0f, 0.0f, 1.0f, 0.0f,
							0.0f, 1.0f, 0.0f, 0.0f,
							posX, posY, posZ, 1.0f);
		}
		else
		{
			cubeFace = 2;
			
			float posX = -dot(positionLight[index].xyz, float3(1.0f, 0.0f, 0.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, 0.0f,-1.0f));
			float posZ = -dot(positionLight[index].xyz, float3(0.0f, 1.0f, 0.0f));
			
			return float4x4(1.0f, 0.0f, 0.0f, 0.0f,
							0.0f, 0.0f,-1.0f, 0.0f,
							0.0f,-1.0f, 0.0f, 0.0f,
							posX, posY, posZ, 1.0f);
		}
	}
	else
	{
		if(normalizedDir.z > 0)
		{
			cubeFace = 4;
			
			float posX = -dot(positionLight[index].xyz, float3(1.0f, 0.0f, 0.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, -1.0f, 0.0f));
			float posZ = -dot(positionLight[index].xyz, float3(0.0f, 0.0f, -1.0f));
			
			return float4x4(1.0f, 0.0f, 0.0f, 0.0f,
							0.0f,-1.0f, 0.0f, 0.0f,
							0.0f, 0.0f, 1.0f, 0.0f,
							posX, posY, posZ, 1.0f);
		}
		else
		{	
			cubeFace = 5;
			
			float posX = -dot(positionLight[index].xyz, float3(-1.0f, 0.0f, 0.0f));
			float posY = -dot(positionLight[index].xyz, float3(0.0f, -1.0f, 0.0f));
			float posZ = -dot(positionLight[index].xyz, float3(0.0f, 0.0f, 1.0f));
			
			return float4x4(-1.0f, 0.0f, 0.0f, 0.0f,
							 0.0f,-1.0f, 0.0f, 0.0f,
							 0.0f, 0.0f,-1.0f, 0.0f,
							 posX, posY, posZ, 1.0f);
		}
	}
}

float ShadowMapCalculate(float4 vPosition_worldspace, int index)
{
	float visibility = 1.0f;
	
	float2 poissonDisk[16] = {
		float2(0.9245183f, -0.008800444f),
		float2(0.4925649f, -0.2221953f),
		float2(0.625096f, -0.6058226f),
		float2(0.4738284f, 0.4412211f),
		float2(0.2358273f, 0.1075331f),
		float2(0.3127747f, -0.8658942f),
		float2(-0.06295051f, -0.6260954f),
		float2(-0.2405405f, -0.03428765f),
		float2(0.423137f, 0.8606744f),
		float2(-0.2479471f, 0.5025519f),
		float2(-0.4603119f, -0.5328533f),
		float2(-0.843367f, -0.2871085f),
		float2(-0.7228245f, 0.1074678f),
		float2(0.01511846f, 0.9717778f),
		float2(-0.8331365f, 0.5342638f),
		float2(-0.400057f, 0.9052021f)
	};

	//Calculate viewLightMatrix
	int cubeFace = 0;
	float4x4 LightViewMatrix = cubeMapping(vPosition_worldspace.xyz - positionLight[index].xyz, index, cubeFace);
	
	if(shadowMapTam[6*index + cubeFace] > 0)
	{	
		float4x4 worldtolight =  mul(LightViewMatrix, projLightMat[index]);
		float4 vPosition_lightspace =  mul(vPosition_worldspace, worldtolight);
		vPosition_lightspace = vPosition_lightspace / vPosition_lightspace.w;
		float3 ShadowCoord;
		ShadowCoord.xy = vPosition_lightspace.xy*0.5f + 0.5f;
		ShadowCoord.y = 1.0f - ShadowCoord.y;
		ShadowCoord.z = vPosition_lightspace.z;
		
		float bias = 0.00001f;//*tan(acos(dot(-vLightDir.xyz, vertexNormal_worldspace.xyz)));
		//bias = clamp(bias, 0.0f,0.01f);
		
		/*float2 AtlasCoord = uvCordShadow[6*index + cubeFace] + (shadowMapTam[6*index + cubeFace]*inverseAtlasSize)*ShadowCoord.xy;
		
		float shadow = texture( atlasShadowSampler, AtlasCoord ).x;
			
		if ( shadow  <  ShadowCoord.z - bias)
		{
			visibility = 0.0f;
		}*/
		
		[unroll]
		for(int i=0; i<4; i++)
		{
			//int index = i;		
			//int index = int(16.0*random(gl_FragCoord.xyy, i))%16;
			uint ramdomIndex = uint(16.0*random(floor(vPosition_worldspace.xyz*1000.0f), i))%16;
			float2 AtlasCoord = uvCordShadow[6*index + cubeFace] + (shadowMapTam[6*index + cubeFace]*inverseAtlasSize)*(ShadowCoord.xy + poissonDisk[ramdomIndex]/700.0f);
			
			float shadow = atlasShadowSampler.SampleLevel( TargetSample, AtlasCoord, 0 ).x;
			
			if ( shadow  <  ShadowCoord.z - bias)
			{
				visibility -= 0.25f;
			}
		}
	}
	
	return visibility;
}

float DirectionalShadowMapCalculate(float4 vPosition_worldspace, int index)
{
	float visibility = 1.0f;
	
	float2 poissonDisk[16] = {
		float2(0.9245183f, -0.008800444f),
		float2(0.4925649f, -0.2221953f),
		float2(0.625096f, -0.6058226f),
		float2(0.4738284f, 0.4412211f),
		float2(0.2358273f, 0.1075331f),
		float2(0.3127747f, -0.8658942f),
		float2(-0.06295051f, -0.6260954f),
		float2(-0.2405405f, -0.03428765f),
		float2(0.423137f, 0.8606744f),
		float2(-0.2479471f, 0.5025519f),
		float2(-0.4603119f, -0.5328533f),
		float2(-0.843367f, -0.2871085f),
		float2(-0.7228245f, 0.1074678f),
		float2(0.01511846f, 0.9717778f),
		float2(-0.8331365f, 0.5342638f),
		float2(-0.400057f, 0.9052021f)
	};
	
	int cubeFace = 0;
	
	if(shadowMapTam[6*index + cubeFace] > 0)
	{	
		float4x4 worldtolight =  mul(lightViewMat[index], projLightMat[index]);
		float4 vPosition_lightspace =  mul(vPosition_worldspace, worldtolight);
		vPosition_lightspace = vPosition_lightspace / vPosition_lightspace.w;
		float3 ShadowCoord;
		ShadowCoord.xy = vPosition_lightspace.xy*0.5f + 0.5f;
		ShadowCoord.y = 1.0f - ShadowCoord.y;
		ShadowCoord.z = vPosition_lightspace.z;
		
		float bias = 0.0023f;//*tan(acos(dot(-vLightDir.xyz, vertexNormal_worldspace.xyz)));
		//bias = clamp(bias, 0.0f,0.01f);
		
		/*float2 AtlasCoord = uvCordShadow[6*index + cubeFace] + (shadowMapTam[6*index + cubeFace]*inverseAtlasSize)*ShadowCoord.xy;
		
		float shadow = texture( atlasShadowSampler, AtlasCoord ).x;
			
		if ( shadow  <  ShadowCoord.z - bias)
		{
			visibility = 0.0f;
		}*/
		
		[unroll]
		for(int i=0; i<4; i++)
		{
			//int index = i;		
			//int index = int(16.0*random(gl_FragCoord.xyy, i))%16;
			uint ramdomIndex = uint(16.0*random(floor(vPosition_worldspace.xyz*1000.0f), i))%16;
			float2 AtlasCoord = uvCordShadow[6*index + cubeFace] + (shadowMapTam[6*index + cubeFace]*inverseAtlasSize)*(ShadowCoord.xy + poissonDisk[ramdomIndex]/2000.0f);
			
			float shadow = atlasShadowSampler.SampleLevel( TargetSample, AtlasCoord, 0 ).x;
			
			if ( shadow  <  ShadowCoord.z - bias)
			{
				visibility -= 0.25f;
			}
		}
	}
	
	return visibility;
}

float4 directionalLightDirectIllumination(float4 diffuseColor, float4 vertexNormal_worldspace, float4 vPosition_worldspace, float4 indirectDiffuse, float4 indirectSpecular,  int lightIndex)
{
	//Shadow Calculate
	float shadowOcclusion = DirectionalShadowMapCalculate(vPosition_worldspace, lightIndex);
	
	//Obtain specular light exponent from normal w
	float exponent = 0.5f*vertexNormal_worldspace.w + 0.5f;
	float kS = diffuseColor.w;

	float4 diff = float4(1.0f, 1.0f, 1.0f, 1.0f)*max(0.0f, dot(-lightDirection[lightIndex].xyz, vertexNormal_worldspace.xyz));
	float3 Refl = -normalize(reflect(-lightDirection[lightIndex].xyz, vertexNormal_worldspace.xyz));
	float3 V = normalize(cameraPosition.xyz - vPosition_worldspace.xyz);
	float s = pow(max(0.0f, dot(Refl, V)), exponent*128.0f);
	float4 spec = diff.x > 0.0f ? s*lightColor[lightIndex] : float4(0.0f, 0.0f, 0.0f, 0.0f);
	
	return max(0.0f, indirectDiffuse.a)*(shadowOcclusion*lightIntensitive[lightIndex]*lightColor[lightIndex]*(diffuseColor*diff + kS*spec) + indirectDiffuse*diffuseColor + indirectSpecular*kS);
}

float4 pointLightDirectIllumination(float4 diffuseColor, float4 vertexNormal_worldspace, float4 vPosition_worldspace, float4 indirectDiffuse, float4 indirectSpecular, int lightIndex)
{	
	//Shadow Calculate
	float shadowOcclusion = ShadowMapCalculate(vPosition_worldspace, lightIndex);
	
	//Obtain specular light exponent from normal w
	float exponent = 0.5f*vertexNormal_worldspace.w + 0.5f;
	float kS = diffuseColor.w;
	
	if(shadowOcclusion <= 0.0f)
		return indirectDiffuse.a*(indirectDiffuse*diffuseColor + indirectSpecular*kS);
	
	float4 Difference = positionLight[lightIndex] - vPosition_worldspace;
	float Distance = length(Difference);
	float att;
	Difference = normalize(Difference);
	
	float4 diff = float4(1.0f, 1.0f, 1.0f, 1.0f)*saturate(dot(Difference, vertexNormal_worldspace));
	
	float3 Refl = -normalize(reflect(Difference.xyz, vertexNormal_worldspace.xyz));
	float3 V = normalize(cameraPosition.xyz - vPosition_worldspace.xyz);
	float s = pow(saturate(dot(Refl, V)), exponent*128.0f);
	float4 spec = diff.x > 0.0f ? s*lightColor[lightIndex] : float4(0.0f, 0.0f, 0.0f, 0.0f);
		
	if(Distance < lightIntensitive[lightIndex]*lightRange[lightIndex])
		att = 1.0f/(attenuationCoeficient[lightIndex].x + (attenuationCoeficient[lightIndex].y/lightRange[lightIndex])*Distance + (attenuationCoeficient[lightIndex].z/(lightRange[lightIndex]*lightRange[lightIndex]))*Distance*Distance);
	else
		att = 0.0f;
	
	return indirectDiffuse.a*(shadowOcclusion*att*lightColor[lightIndex]*lightIntensitive[lightIndex]*(diffuseColor*diff + kS*spec) + indirectDiffuse*diffuseColor + indirectSpecular*kS);
	
	//return shadowOcclusion*float4(1.0f, 1.0f, 1.0f, 1.0f);
}

float4 spotLightDirectIllumination(float4 diffuseColor, float4 vertexNormal_worldspace, float4 vPosition_worldspace, int lightIndex)
{
	float4 Difference = positionLight[lightIndex] - vPosition_worldspace;
	float Distance = length(Difference);
	float att;
	Difference = normalize(Difference);
	
	//Obtain specular light exponent from normal w
	float exponent = 0.5f*vertexNormal_worldspace.w + 0.5f;
	float kS = diffuseColor.w;
	
	float cos_cur_angle = dot(-lightDirection[lightIndex], Difference);
	
	float cos_thetaAngle = cos(thetaAngle[lightIndex]);
	float cos_phiAngle = cos(phiAngle[lightIndex]);
	float cos_inner_minus_outer_angle = cos_thetaAngle - cos_phiAngle;
	
	if (cos_cur_angle > cos_thetaAngle) 
	{
		float4 diff = float4(1.0f, 1.0f, 1.0f, 1.0f)*saturate(dot(Difference, vertexNormal_worldspace));
	
		float3 Refl = -normalize(reflect(Difference.xyz, vertexNormal_worldspace.xyz));
		float3 V = normalize(cameraPosition.xyz - vPosition_worldspace.xyz);
		float s = pow(saturate(dot(Refl, V)), exponent*128.0f);
		float4 spec = diff.x > 0.0f ? s*lightColor[lightIndex] : float4(0.0f, 0.0f, 0.0f, 0.0f);
			
		if(Distance < lightIntensitive[lightIndex]*lightRange[lightIndex])
			att = 1.0f/(attenuationCoeficient[lightIndex].x + (attenuationCoeficient[lightIndex].y/lightRange[lightIndex])*Distance + (attenuationCoeficient[lightIndex].z/(lightRange[lightIndex]*lightRange[lightIndex]))*Distance*Distance);
		else
			att = 0.0f;
		
		return att*lightColor[lightIndex]*lightIntensitive[lightIndex]*(diffuseColor*diff + kS*spec);
	}
	else if( cos_cur_angle > cos_phiAngle )
	{
		float falloff = (cos_cur_angle - cos_phiAngle) / 
		cos_inner_minus_outer_angle;
		
		float4 diff = float4(1.0f, 1.0f, 1.0f, 1.0f)*saturate(dot(Difference, vertexNormal_worldspace));
	
		float3 Refl = -normalize(reflect(Difference.xyz, vertexNormal_worldspace.xyz));
		float3 V = normalize(cameraPosition.xyz - vPosition_worldspace.xyz);
		float s = pow(saturate(dot(Refl, V)), exponent*128.0f);
		float4 spec = diff.x > 0.0f ? s*lightColor[lightIndex] : float4(0.0f, 0.0f, 0.0f, 0.0f);
			
		if(Distance < lightIntensitive[lightIndex]*lightRange[lightIndex])
			att = 1.0f/(attenuationCoeficient[lightIndex].x + (attenuationCoeficient[lightIndex].y/lightRange[lightIndex])*Distance + (attenuationCoeficient[lightIndex].z/(lightRange[lightIndex]*lightRange[lightIndex]))*Distance*Distance);
		else
			att = 0.0f;
		
		return falloff*att*lightColor[lightIndex]*lightIntensitive[lightIndex]*(diffuseColor*diff + kS*spec);
	}
	
	return float4(0.0f, 0.0f, 0.0f, 0.0f);	
}

float4 inDirectIllumination(float4 diffuseColor, float4 indirectDiffuse, float4 indirectSpecular)
{
	float kS = diffuseColor.w;
	
	return indirectDiffuse*diffuseColor + indirectSpecular*kS;
}

float4 main(PsIn In) : SV_Target
{
	float4 color;

	float4 baseColor = baseTarget.Sample( TargetSample, In.vertexUV );
	float4 vertexNormal_worldspace = normalTarget.Sample( TargetSample, In.vertexUV );
	float4 indirectDiffuse = indirectDiffuseTarget.Sample( TargetSample, In.vertexUV );
	float4 indirectSpecular = indirectSpecularTarget.Sample( TargetSample, In.vertexUV );
	float depth = depthTarget.Sample( TargetSample, In.vertexUV ).x;
	
	bool oneTimeEmissive = bOneTimeEmissive == 1 ? true : false;
	
	//if(depth <= 0)
		//discard;
	
	//Obtain world space position coordinates	
	float3 viewRay = normalize(In.ViewRay.xyz);
	float4 vPosition_worldspace = float4(cameraPosition.xyz + viewRay*depth, 1.0f);
	
	float4 directIllumination = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
	if(indirectSpecular.a <= 0.0f)
	{	
		for(int i=0; i<numLights || oneTimeEmissive; i++)
		{
			if(numLights != 0)
			{
				indirectDiffuse = oneTimeEmissive ? indirectDiffuse : float4(0.0f, 0.0f, 0.0f, 0.0f);
				indirectSpecular = oneTimeEmissive ? indirectSpecular : float4(0.0f, 0.0f, 0.0f, 0.0f);
			
				if(lightType[i] == 0)
				{
					directIllumination += directionalLightDirectIllumination(baseColor, vertexNormal_worldspace, vPosition_worldspace, indirectDiffuse, indirectSpecular, i);
				}
				if(lightType[i] == 1)
				{
					directIllumination += pointLightDirectIllumination(baseColor, vertexNormal_worldspace, vPosition_worldspace, indirectDiffuse, indirectSpecular, i);
				}
				if(lightType[i] == 2)
				{
					directIllumination += spotLightDirectIllumination(baseColor, vertexNormal_worldspace, vPosition_worldspace, i);
				}
			}
			else
			{
				directIllumination += inDirectIllumination(baseColor,indirectDiffuse, indirectSpecular);
			}
			
			oneTimeEmissive = false;
		}
	}
	else
	{
		directIllumination = baseColor*indirectSpecular.a;
	}
		
	
	color = directIllumination;
	color.a = 1.0f;
	
	return color;
}
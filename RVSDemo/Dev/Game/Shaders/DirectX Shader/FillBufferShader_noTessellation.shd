/////////////////////////////////////////////////////////////////////////////////
//																			   //
//		SIMPLE FILLBUFFERSHADER	(SIMPLE LIGHTING)			   				   //
//																			   //
/////////////////////////////////////////////////////////////////////////////////

// Input data
struct VsIn 
{
	float3 vertexPosition_modelspace : Position;
	float3 vertexNormal_modelspace	 : Normal;
	float2 vertexUV_modelspace		 : TexCoord;
	float3 vertexTangent_modelspace	 : Tangent;
	float3 vertexBinormal_modelspace : Binormal;
};

// Output data
struct PsIn 
{
	float3 vertexNormal_worldspace   : Normal;
	float4 vertexDepth_projectspace  : SV_Position;
	float4 vertexPosition_viewSpace  : TexCoord0;
	float4 vertexPosition_worldspace : TexCoord1;
	float2 vertexUV					 : TexCoord2;
	float3 vertexTangent_worldspace  : Tangent;
	float3 vertexBinormal_worldspace : Binormal;
};

[Vertex shader]

float4x4 World;
float4x4 View;
float4x4 Projection;

PsIn main(VsIn In)
{
	PsIn output;
	
	float4 vertexPosition_worldspace = mul(float4(In.vertexPosition_modelspace, 1.0f), World);
	output.vertexPosition_viewSpace = mul(vertexPosition_worldspace, View);
	float4 worldViewProjPosition = mul(output.vertexPosition_viewSpace, Projection);
	output.vertexDepth_projectspace = worldViewProjPosition;
	
	output.vertexPosition_worldspace = vertexPosition_worldspace;
	output.vertexNormal_worldspace = normalize(mul(float4(In.vertexNormal_modelspace, 0.0f), World).xyz);
	output.vertexUV.x = In.vertexUV_modelspace.x;
	output.vertexUV.y = 1.0f - In.vertexUV_modelspace.y;
	output.vertexTangent_worldspace = normalize(mul(float4(In.vertexTangent_modelspace, 0.0f), World).xyz);
	output.vertexBinormal_worldspace = normalize(mul(float4(In.vertexBinormal_modelspace, 0.0f), World).xyz);
	
	return output;
 }

[Fragment shader]

struct PsOut 
{
	float depthRT	  : SV_Target0;
	float4 normalRT   : SV_Target1;
	float4 albedoRT   : SV_Target2;
	float4 MREC_RT	  : SV_Target3;
};

//Textures////////////////////////////////
Texture2D texAlbedoMap;
Texture2D texNormalMap;
Texture2D texMRECMap;
//////////////////////////////////////////

//Sampler States//////////////////////////
SamplerState BaseFilter;
//////////////////////////////////////////

//Material////////////////////////////////
float4 vAlbedoColor;

float fMetalic;
float fRoughness;
float fEmissive;

int iMREC_Channel[4];

int bAlbedoMap;
int bNormalMap;
int bMetalicMap;
int bRoughnessMap;
int bEmissionMap;
int bCavityMap;

int bParallaxMap;

float fDisplacementScale;
////////////////////////////////////////////

//Camera constant
float4 vCameraPosition;

//Parallax Occlusion Mapping/////////////////////////////////////////////////////

float2 parallaxMapping(float3 ViewDir_tangentspace, float3 ViewDir_worldspace, float2 T, float3 normal_worldSpace, out float parallaxHeight)
{
	ViewDir_worldspace = normalize(ViewDir_worldspace);

	// determine optimal number of layers
	const float minLayers = 10;
	const float maxLayers = 100;
	int nNumSteps = (int)lerp( maxLayers, minLayers, dot( ViewDir_worldspace, normal_worldSpace ) );
	
	parallaxHeight = 0.08f;
	
	float2 vParallaxDirection = -normalize(ViewDir_tangentspace.xy);
	
	// The length of this vector determines the furthest amount of displacement:
    float fLength         = length(ViewDir_tangentspace);
    float fParallaxLength = sqrt( fLength * fLength - ViewDir_tangentspace.z * ViewDir_tangentspace.z ) / ViewDir_tangentspace.z; 
       
    // Compute the actual reverse parallax displacement vector:
    float2 vParallaxOffsetTS = vParallaxDirection * fParallaxLength * fDisplacementScale;
	
	// Compute all the derivatives:
	float2 dx = ddx(T);
	float2 dy = ddy(T);
	
	float fCurrHeight = 0.0;
	float fStepSize   = 1.0 / (float) nNumSteps;
	float fPrevHeight = 1.0;
	float fNextHeight = 0.0;
	
	int    nStepIndex = 0;
	bool   bCondition = true;

	float2 vTexOffsetPerStep = fStepSize * vParallaxOffsetTS;
	float2 vTexCurrentOffset = T;
	float  fCurrentBound     = 1.0;
	float  fParallaxAmount   = 0.0;

	float2 pt1 = 0;
	float2 pt2 = 0;

	float2 texOffset2 = 0;
   
	while ( nStepIndex < nNumSteps ) 
	{
		vTexCurrentOffset -= vTexOffsetPerStep;

		// Sample height map which in this case is stored in the alpha channel of the normal map:
		fCurrHeight = texNormalMap.SampleGrad( BaseFilter, vTexCurrentOffset, dx, dy ).a;

		fCurrentBound -= fStepSize;

		if ( fCurrHeight > fCurrentBound ) 
		{     
			pt1 = float2( fCurrentBound, fCurrHeight );
			pt2 = float2( fCurrentBound + fStepSize, fPrevHeight );

			texOffset2 = vTexCurrentOffset - vTexOffsetPerStep;

			nStepIndex = nNumSteps + 1;
		}
		else
		{
			nStepIndex++;
			fPrevHeight = fCurrHeight;
		}
	}   // End of while ( nStepIndex < nNumSteps )
   
	float fDelta2 = pt2.x - pt2.y;
	float fDelta1 = pt1.x - pt1.y;
	float fDenominator = fDelta2 - fDelta1;
      
	// SM 3.0 and above requires a check for divide by zero since that operation will generate an 'Inf' number instead of 0
	[flatten]if ( fDenominator == 0.0f ) 
	{
		fParallaxAmount = 0.0f;
	}
	else
	{
		fParallaxAmount = ( pt1.x * fDelta2 - pt2.x * fDelta1 ) / fDenominator;
	}
   
	float2 vParallaxOffset = vParallaxOffsetTS * ( 1.0 - fParallaxAmount );
	
	return T - vParallaxOffset;
}
////////////////////////////////////////////////////////////////////////////////////

PsOut main(PsIn In)
{
	PsOut output;
	float2 parallaxUVCoord = In.vertexUV;	
	float parallaxHeight;
	
	output.albedoRT = float4(0.0f, 0.0f, 0.0f, 0.0f);
	output.normalRT = float4(0.0f, 0.0f, 0.0f, 0.0f);
	output.MREC_RT = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
	float4 vMREC_Value;
	
	if(bNormalMap)
	{
		float3 tangent_worldSpace = In.vertexTangent_worldspace;
		tangent_worldSpace = float3(tangent_worldSpace.x, tangent_worldSpace.y, tangent_worldSpace.z);
		float3 normal_worldSpace = In.vertexNormal_worldspace;
		float3 binormal_worldSpace = In.vertexBinormal_worldspace;
		float3x3 matInverse = float3x3(tangent_worldSpace, binormal_worldSpace, normal_worldSpace);		
		
		if(bParallaxMap)
		{
			float3x3 matInverseParallaxMap = matInverse;
			matInverseParallaxMap._m00_m02 = -matInverseParallaxMap._m00_m02;
			float3 ViewDir_worldspace = vCameraPosition.xyz - In.vertexPosition_worldspace;
			float3 ViewDir_tangentspace = mul(matInverse, ViewDir_worldspace);
			parallaxUVCoord = parallaxMapping(ViewDir_tangentspace, ViewDir_worldspace, In.vertexUV, In.vertexNormal_worldspace, parallaxHeight);
		}
		
		float3 bumpNormal = normalize(2.0f*(texNormalMap.Sample(BaseFilter , parallaxUVCoord).rgb - 0.5f));
				
		bumpNormal = mul(bumpNormal, matInverse);
		
		output.normalRT = float4(bumpNormal, 0.0f);
	}
	else
	{
		output.normalRT = float4(In.vertexNormal_worldspace, 0.0f);
	}
	
	if(bAlbedoMap)
	{
		output.albedoRT = texAlbedoMap.Sample(BaseFilter, parallaxUVCoord);
	}
	else
	{
		output.albedoRT = vAlbedoColor;
	}
	
	if(bMetalicMap || bRoughnessMap || bEmissionMap || bCavityMap)
		vMREC_Value = texMRECMap.Sample(BaseFilter, parallaxUVCoord);
	
	if(bMetalicMap)
	{
		output.MREC_RT.x = vMREC_Value[iMREC_Channel[0]];
	}
	else
	{
		output.MREC_RT.x = fMetalic;
	}
	
	if(bRoughnessMap)
	{
		output.MREC_RT.y = vMREC_Value[iMREC_Channel[1]];
	}
	else
	{
		output.MREC_RT.y = fRoughness;
	}
	
	if(bEmissionMap)
	{
		output.MREC_RT.z = vMREC_Value[iMREC_Channel[2]];
	}
	else
	{
		output.MREC_RT.z = fEmissive;
	}
	
	if(bCavityMap)
	{
		output.MREC_RT.w = vMREC_Value[iMREC_Channel[3]];
	}
	
	output.depthRT = length(In.vertexPosition_viewSpace.xyz);
	
	return output;
}